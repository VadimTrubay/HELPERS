# Git commands

git status 
git branch -vv
git switch -c ...
git push --set-upstream origin ...
git branch -vv


Чтобы создать новую ветку и опубликовать её на удалённом репозитории, выполните следующие шаги:
Создайте и переключитесь на новую ветку:
git push -u origin <new-branch-name>
Флаг -u устанавливает связь между локальной веткой и удалённой, чтобы в будущем можно было просто использовать git push без указания имени ветки.
1. git switch -c feature/new-feature
2. git push -u origin feature/new-feature
После этого ветка feature/new-feature будет доступна на удалённом репозитории.

create repository in git
echo "# 1" >> README.md
git init
git add .
git commit -m "initial commit"
git branch -M main
git remote add origin https://github.com/...
git push origin main

git remote -v - check all remote repo
"git clone <repo-url>" - клонує віддалений репозиторій тобі на комп'ютер
"code ." - відкриває VSCode в поточній директорії
"git status" - відображає поточний стан репозиторію
"git add ." - додає під контроль усі нові зміни в поточній директорії
"git commit -m <Your message>" - фіксує поточний стан файлів у локальному репозиторії
"git stash" - тимчасово зберігає незафіксовані зміни
"git push" - відправляє зафіксовані зміни у віддалений репозиторій

"git branch" - показує лише локальні гілки
"git branch -r" - показує лише віддалені гілки
"git branch -a" - показує усі гілки, як локальні так і віддалені

"git switch -c <name new branch>" - команда для створення нової гілки
"git switch <name branch>" - команда щоб перейти на іншу гілку

"git fetch" - завантажує останні зміни з віддаленого репозиторію,
але не вносить їх у поточні гілки.
Вона використовується для оновлення локальної інформації
про стан віддаленого репозиторію, але не змінює ваш робочий каталог

"git pull" - одночасно і завантажує, і вносить у локальний репозиторій усі останні
зміни (на усіх гілках), які були зроблені у віддаленому репозиторію.
Якщо потрібно завантажити зміни з певної гілки, то треба додати до команди
назву цієї гілки, наприклад, git pull origin footer

"git pull origin main" - завантажує останні зміни з віддаленого репозиторію main

"git switch main" - Переключись на гілку main
"git merge <name branch>" - Злиття гілки <name branch> з main
"git push origin main" - Ці дії об'єднають зміни з гілки <name branch> до гілки main і оновлять
віддалений репозиторій з останнім станом гілки main

"git branch -d(D) <name branch>" - команда для видалення гілки, (-D — це примусове видалення)
"git push origin --delete <name branch>" - видалити віддалену гілку можна за допомогою команди
"git push -u origin <назва_гілки>" - Ця команда створює гілку на віддаленому репозиторіїі встановлює зв'язок для 
подальшого пушу.
"git log" - для перегляду історії, щоб переконатися, що злиття було успішно здійснено

# Team_git

git branch — показує лише локальні гілки
git branch -r — показує лише віддалені гілки
git branch -a — показує усі гілки, як локальні так і віддалені
git switch -c name-your-branch — створює нову гілку
git switch name-branch — переключає на іншу гілку
git fetch — завантажує останні зміни з віддаленого репозиторію, але не вносить їх у поточні гілки
git pull — одночасно і завантажує, і вносить у локальний репозиторій усі останні зміни (на усіх гілках), які були 
зроблені у віддаленому репозиторію
git pull origin footer — завантажить і застосує усі зміни з віддаленої (origin ) гілки footer до локальної
git commit — застосує коміти до поточної гілки
git merge page-header — зливає у поточну гілку код з гілки page-header
git push origin main — віддаленої гілки main
git branch -d page-header — видаляє локальну гілку page-header

Щоб додати колабораторів до проєкту:

Перейди у розділ Settings (укр**. Налаштування)** репозиторію
У підрозділі Access (укр. Доступи) обери пункт Collaborators (укр. Колаборатори)
Натисни на кнопку Add people (укр. Додати людину)
Введи ім'я користувача GitHub або електронну пошту особи, яку ти хочеш додати, наприклад, teammate-goit та обери її 
із випадаючого списку
Натисни кнопку Add to this repository.

Давай для прикладу розглянемо популярний варіант, коли на гілку main роблять захист від прямого внесення змін.

Для цього потрібно:

вибрати варіант Require a pull request before merging (що таке pull request ти дізнаєшся далі).
Автоматично позначиться обраною опція Require approvals, яка вимагатиме для злиття одне погодження.

Для налаштування гілки потрібно:

Відкрити відповідний репозиторій на GitHub
Зайти у його Settings (укр. Налаштування)
Обрати меню Branches (укр. Гілки)
Нажати на кнопку Add branch protection rule (укр. Додати правило захисту гілок)
У обов’язкове для заповнення поле Branch name pattern ввести назву гілки, до якої має застосовуватись дане правило, 
наприклад, main
Обрати з переліку усіх доступних правил ті, які ти хочеш застосувати до вказаної гілки
Коли всі опції обрані, нажати на кнопку Create (укр. Створити)

Для того, щоб створити Pull Request:

Переконайся, що були внесені потрібні зміни у твою локальну гілку, наприклад footer, і вони були запушені до 
віддаленої гілки
Перейди на сторінку GitHub і відкрий командний репозиторій
Перейди у вкладку Pull requests.
Натисни на кнопку New pull request
Вибери 1) гілку, з якої потрібно злити зміни (source branch), і 2) гілку, у яку потрібно злити зміни (target branch), 
зазвичай це основна гілка проекту main
Переглянь список змін і переконайся, що ти відправляєш правильні зміни
Натисни Сreate pull request
Введи назву та опис для PR, які пояснюють зміни

PR створено і тепер потрібно його перевірити і надати ревью.

Для цього:

Перейди у розділ Pull Requests відповідного репозиторію на GitHub
Обери зі списку той PR, який потребує перевірки
Натисни на кнопку Add your review
Ретельно переглянь код на наявність помилок, неточностей та інших важливих аспектів. Залиш коментарі щодо проблемних
місць, якщо такі є під відповідним рядком, використовуючи синю кнопку з плюсом і Start your review
Після перевірки всього коду натисни Finish your review, залишивши коментар за потреби
Вибери один із трьох варіантів: Request changes (запросити зміни), Approve (погодити) або Comments (лише прокоментувати)
Якщо вибрано Approve, кнопка Merge pull request стане активною. Натисни на цю кнопку, щоб ініціювати злиття
Натисни Confirm merge для завершення процесу злиття
Після успішного злиття гілок, наприклад, footer у main, можна видалити гілку footer за допомогою кнопки Delete branch

Дай рекомендації розробнику:

виконати git pull з цільової гілки main (до якої має відбутися злиття) у поточну гілку header (яку мають злити з цільовою)
вирішити конфлікти у себе локально
запушити ці зміни у поточну гілку header на GitHub
Після внесення змін розробником та відправлення їх на GitHub, не потрібно створювати новий PR, якщо попередній було лише 
прокоментовано або в нього було внесено запит на зміни (Request changes). Усі зміни, внесені у поточну гілку (header), 
автоматично з'являться в уже існуючому PR.


# Create_project

git branch — показує лише локальні гілки
git branch -r — показує лише віддалені гілки
git branch -a — показує усі гілки, як локальні так і віддалені
git switch -c name-your-branch — створює нову гілку
git switch name-branch — переключає на іншу гілку
git fetch — завантажує останні зміни з віддаленого репозиторію, але не вносить їх у поточні гілки
git pull — одночасно і завантажує, і вносить у локальний репозиторій усі останні зміни (на усіх гілках), які були 
зроблені у віддаленому репозиторію
git pull origin footer — завантажить і застосує усі зміни з віддаленої (origin ) гілки footer до локальної
git commit — застосує коміти до поточної гілки
git merge page-header — зливає у поточну гілку код з гілки page-header
git push origin main — віддаленої гілки main
git branch -d page-header — видаляє локальну гілку page-header


тобы удалить коммиты с помощью интерактивного rebase в Git с использованием редактора Vim, нужно выполнить
несколько шагов. Я подробно опишу процесс работы с Vim, начиная от запуска команды и до завершения редактирования 
коммитов.

Шаги для интерактивного rebase с использованием Vim:
Запуск команды интерактивного rebase:

Для начала, откройте терминал и выполните команду git rebase -i HEAD~n, где n — это количество последних коммитов, 
которые вы хотите изменить или удалить.

bash
Копіювати код
git rebase -i HEAD~3
Эта команда откроет редактор Vim с списком последних трёх коммитов.

Работа в Vim:

Когда откроется Vim, вы увидите список коммитов с их хэшами и сообщениями. Перед каждым коммитом будет стоять слово 
pick, что означает "оставить этот коммит без изменений".

sql
Копіювати код
pick abcdef1 Commit message 1
pick abcdef2 Commit message 2
pick abcdef3 Commit message 3
Переключение в режим редактирования:

Чтобы начать редактирование файла, нужно перейти в режим редактирования. Для этого:

Нажмите i на клавиатуре. Вы увидите, что в нижнем левом углу экрана появится индикатор -- INSERT --, что означает, 
что вы находитесь в режиме вставки и можете редактировать текст.
Редактирование коммитов:

Теперь вы можете изменить слово pick на:

drop, если хотите удалить этот коммит.
reword, если хотите изменить сообщение коммита.
edit, если хотите внести изменения в этот коммит.
Например, чтобы удалить второй коммит, измените строку:

sql
Копіювати код
pick abcdef2 Commit message 2
на:

sql
Копіювати код
drop abcdef2 Commit message 2
Выход из режима редактирования и сохранение изменений:

После того как вы внесли необходимые изменения:

Нажмите Esc для выхода из режима редактирования. Индикатор -- INSERT -- исчезнет.

Введите :wq и нажмите Enter, чтобы сохранить изменения и выйти из Vim.

:w — это команда для сохранения файла.
:q — это команда для выхода из Vim.
Завершение rebase:

Git применит ваши изменения. Если были удалены коммиты или изменены сообщения, Git пересоберет историю и выполнит 
все необходимые операции.

Если во время rebase возникнут конфликты, Git сообщит об этом, и вы сможете разрешить их вручную. После разрешения 
конфликтов нужно будет продолжить rebase с помощью команды:

bash
Копіювати код
git rebase --continue
Полезные команды и горячие клавиши в Vim:
i — войти в режим редактирования (вставки).
Esc — выйти из режима вставки.
x — удалить символ под курсором.
dd — удалить текущую строку.
u — отменить последнее действие.
:wq — сохранить изменения и выйти из Vim.
:q! — выйти из Vim без сохранения изменений.
gg — перейти в начало файла.
G — перейти в конец файла.
/ — поиск по тексту (вводите текст и нажимаете Enter для поиска).
Эти инструкции помогут вам эффективно работать с Vim во время выполнения операций с Git, таких как интерактивный rebase.




Эти инструкции помогут вам эффективно работать с Vim во время выполнения операций с Git, таких как интерактивный rebase.



Ви сказали:
(venv) PS D:\work_it\github\internship_meduzzen_backend> git rebase --continue
error: invalid command 'A'
error: invalid line 1: A
error: please fix this using 'git rebase --edit-todo'.
(venv) PS D:\work_it\github\internship_meduzzen_backend> git rebase --edit-todo
error: invalid command 'A'
error: invalid line 1: A
error: invalid command 'A'
error: invalid line 1: A
You can fix this with 'git rebase --edit-todo' and then run 'git rebase --continue'.
Or you can abort the rebase with 'git rebase --abort'.
(venv) PS D:\work_it\github\internship_meduzzen_backend>
Програма ChatGPT сказала:
ChatGPT
Ошибка, с которой вы столкнулись, связана с неправильным форматом файла rebase-todo, который используется Git во время интерактивного rebase. Команда A, которая указана в первой строке файла, не является допустимой командой для этого файла. Давайте рассмотрим, как это исправить.

Шаги для исправления ошибки:
Запуск git rebase --edit-todo:

Вы уже запустили эту команду и увидели ошибку. Это означает, что в файле rebase-todo есть неверная строка.

Редактирование файла rebase-todo:

Чтобы исправить ошибку, нужно отредактировать файл вручную.

Windows: Находясь в той же директории, откройте файл rebase-todo с помощью текстового редактора (например, Notepad, VSCode и т. д.).

Путь к файлу можно найти следующим образом:

bash
Копіювати код
.git/rebase-merge/git-rebase-todo
Откройте этот файл с помощью текстового редактора.

Linux/MacOS: Вы можете использовать команду vim или nano для редактирования:

bash
Копіювати код
vim .git/rebase-merge/git-rebase-todo
Исправление строки:

Открыв файл, вы должны увидеть строки, содержащие команды для rebase (pick, reword, edit, drop и т.д.). 
Ваша цель — найти и исправить неверную строку, которая содержит A.

Например:

bash
Копіювати код
A abcdef1 Commit message 1
Замените A на правильную команду. Если вы не уверены, что нужно сделать с этим коммитом, вы можете 
заменить A на pick, чтобы сохранить коммит:

bash
Копіювати код
pick abcdef1 Commit message 1
Сохранение и выход:

После внесения изменений сохраните файл и закройте редактор.

Продолжение rebase:

После исправления файла выполните команду:

bash
Копіювати код
git rebase --continue
Git продолжит процесс rebase с учетом внесенных вами исправлений.

В случае дальнейших проблем:

Если проблема не решена или возникают новые ошибки, всегда можно прервать rebase и вернуться к исходной ветке:

bash
Копіювати код
git rebase --abort
Эта команда отменит все изменения, сделанные во время текущего rebase, и вернет вас к состоянию до его начала.


Ошибка, с которой вы столкнулись, указывает на проблему с обновлением ссылки (ref) на ветку develop. Это может
произойти, если во время выполнения rebase кто-то или что-то изменило состояние ветки, из-за чего текущее состояние 
ветки не совпадает с ожидаемым.

Возможные решения
Принудительное обновление референса с помощью git reflog:

Эта команда поможет восстановить состояние ветки до начала rebase.

Сначала отмените текущий rebase, чтобы вернуться к стабильному состоянию:

bash
Копіювати код
git rebase --abort
Затем проверьте журнал действий, используя git reflog, чтобы найти коммит, к которому вы хотите вернуться:

bash
Копіювати код
git reflog
В списке найдите нужный коммит и выполните команду для возврата к этому состоянию:

bash
Копіювати код
git reset --hard <commit_hash>
Где <commit_hash> — это хэш коммита, к которому вы хотите вернуться.

Принудительное обновление ветки:

Если вы уверены, что изменения в локальной ветке develop верны и вам нужно их сохранить, вы можете попытаться 
принудительно обновить ссылку:

Сначала выполните git rebase --abort, чтобы прервать текущий rebase.

Затем выполните команду:

bash
Копіювати код
git update-ref -d refs/heads/develop
После этого переключитесь на ветку develop и продолжите работу:

bash
Копіювати код
git checkout develop
git rebase <target_branch>
Проверка и разрешение конфликта:

Эта ошибка может указывать на существование конфликта в обновлении ветки, возможно, из-за вмешательства другой 
ветки или процесса.

Убедитесь, что у вас нет других процессов, которые могут влиять на эту ветку (например, параллельные git операции).

Если у вас есть доступ к удалённому репозиторию, убедитесь, что нет конфликтов с ним. Например, выполните:

bash
Копіювати код
git pull origin develop
Это обновит локальную ветку с удалённой и может разрешить проблему.

Использование git reflog для восстановления ветки:

Если проблема возникла из-за нарушения ссылки, попробуйте восстановить ветку из журнала референсов:

Посмотрите последние изменения в ветке:

bash
Копіювати код
git reflog show develop
Найдите хэш комита до возникновения проблемы и выполните:

bash
Копіювати код
git reset --hard <commit_hash>
Принудительное обновление (force push) на удалённый репозиторий:

Если вы работаете с удалённым репозиторием и произошёл конфликт:

Вы можете выполнить принудительный пуш:

bash
Копіювати код
git push origin develop --force
Это может помочь синхронизировать локальную и удалённую ветки.

Заключение
Эти шаги должны помочь вам восстановить состояние ветки develop и продолжить работу. 
В зависимости от вашего рабочего процесса и состояния репозитория, используйте самый подходящий метод.
Всегда помните, что принудительное изменение ветки может привести к потере данных, поэтому рекомендуется 
сначала создавать резервные копии или проверять действия перед их выполнением.


Чтобы откатить изменения и решить конфликт, выполните следующие шаги:

1. Просмотреть текущие изменения
Чтобы убедиться, какие файлы находятся в конфликте, выполните:

bash
Copy code
git status
2. Откатить изменения файла с конфликтом
Если вы хотите полностью откатить изменения и оставить состояние ветки dev таким, каким оно было в удалённом репозитории, выполните:

bash
Copy code
git checkout --theirs .github/workflows/linters.yml
Это заменит содержимое файла версией из удалённой ветки (origin/dev).

Или, если вы хотите оставить свою текущую версию файла:

bash
Copy code
git checkout --ours .github/workflows/linters.yml
3. Убедиться, что конфликт устранён
После выбора нужной версии файла проверьте статус:

bash
Copy code
git status
Файл должен перейти в состояние "готов к коммиту" (staged).

4. Завершить слияние
Закончите процесс слияния с помощью:

bash
Copy code
git add .github/workflows/linters.yml
git commit
Если нужно полностью откатить попытку слияния:

bash
Copy code
git merge --abort
5. Повторить попытку
После исправления можно снова выполнить:

bash
Copy code
git pull origin dev

Чтобы связать новую ветку feature/websockets_vadim с удалённым репозиторием, выполните следующие шаги:

1. Проверьте статус ветки
Убедитесь, что локальная ветка создана и не привязана к удалённой:

bash
Copy code
git branch -vv
Если рядом с вашей веткой feature/websockets_vadim нет ссылки на удалённый репозиторий, значит ветка пока не связана.

2. Привязать ветку к удалённой
Для привязки ветки к удалённой выполните следующую команду:

bash
Copy code
git push --set-upstream origin feature/websockets_vadim
Эта команда создаст ветку в удалённом репозитории и привяжет локальную ветку к удалённой. После этого можно использовать команды вроде git pull и git push без дополнительных параметров.

3. Проверить результат
После успешной привязки выполните:

bash
Copy code
git branch -vv
Теперь должно отображаться, что ветка feature/websockets_vadim привязана к origin/feature/websockets_vadim.

4. Если ветка уже существует в удалённом репозитории
Если вы точно знаете, что такая ветка уже есть в удалённом репозитории, просто выполните:

bash
Copy code
git pull origin feature/websockets_vadim
Затем подтвердите привязку:

bash
Copy code
git branch --set-upstream-to=origin/feature/websockets_vadim
Теперь всё готово, и локальная ветка синхронизирована с удалённой.






